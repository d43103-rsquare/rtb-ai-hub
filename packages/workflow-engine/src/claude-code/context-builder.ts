/**
 * Context Builder — debate 결과물 + 컨텍스트 → CLAUDE.md 생성
 *
 * debate 결과, Jira 컨텍스트, Wiki 지식, Figma 데이터, 코딩 규칙을
 * 구조화된 CLAUDE.md 파일로 변환한다.
 */

import type {
  DebateSession,
  DebateArtifact,
  DebateContext,
  Environment,
} from '@rtb-ai-hub/shared';
import { createLogger } from '@rtb-ai-hub/shared';

const logger = createLogger('context-builder');

export type ContextBuildInput = {
  debateSession: DebateSession;
  context: DebateContext;
  env: Environment;
  codingGuidelines?: string;
  projectStructure?: string;
  policyConstraints?: string;
};

/** Build CLAUDE.md content from debate results and context */
export function buildClaudeMd(input: ContextBuildInput): string {
  const sections: string[] = [];

  // Header
  sections.push(`# ${input.context.jiraKey} — Implementation Guide
Generated by RTB AI Hub Debate Engine
Environment: ${input.env}`);

  // Debate Decision
  sections.push(buildDebateDecisionSection(input.debateSession));

  // Implementation Artifacts
  const implArtifacts = input.debateSession.turns.flatMap((t) => t.artifacts);
  if (implArtifacts.length > 0) {
    sections.push(buildArtifactsSection(implArtifacts));
  }

  // Jira Context
  sections.push(buildJiraContextSection(input.context));

  // Wiki Knowledge
  if (input.context.wikiKnowledge) {
    sections.push(`## Domain Knowledge (Wiki)
${input.context.wikiKnowledge}`);
  }

  // Figma Context
  if (input.context.figmaContext) {
    sections.push(`## Design Context (Figma)
${input.context.figmaContext}`);
  }

  // Code Context
  if (input.context.codeContext) {
    sections.push(`## Existing Code Context
${input.context.codeContext}`);
  }

  // Previous Decisions
  if (input.context.previousDecisions) {
    sections.push(`## Previous Decisions
${input.context.previousDecisions}`);
  }

  // Coding Guidelines
  if (input.codingGuidelines) {
    sections.push(`## Coding Guidelines
${input.codingGuidelines}`);
  }

  // Project Structure
  if (input.projectStructure) {
    sections.push(`## Project Structure
${input.projectStructure}`);
  }

  // Policy Constraints
  if (input.policyConstraints) {
    sections.push(input.policyConstraints);
  }

  // Implementation Instructions
  sections.push(buildInstructionsSection(input.env));

  logger.info(
    {
      jiraKey: input.context.jiraKey,
      sections: sections.length,
      artifacts: implArtifacts.length,
    },
    'CLAUDE.md built'
  );

  return sections.join('\n\n---\n\n');
}

// ─── Section Builders ──────────────────────────────────────────────────────────

function buildDebateDecisionSection(session: DebateSession): string {
  const outcome = session.outcome;
  if (!outcome) return '## Debate Decision\nNo outcome yet.';

  return `## Debate Decision
**Status**: ${outcome.status}
**Decision**: ${outcome.decision}

### Debate Summary
- **Turns**: ${session.turns.length}
- **Participants**: ${[...new Set(session.turns.map((t) => t.agent))].join(', ')}
- **Cost**: $${session.totalCostUsd.toFixed(4)}

${outcome.dissentingViews && outcome.dissentingViews.length > 0
    ? `### Dissenting Views\n${outcome.dissentingViews.map((v) => `- **${v.agent}**: ${v.view.slice(0, 200)}`).join('\n')}`
    : ''}`;
}

function buildArtifactsSection(artifacts: DebateArtifact[]): string {
  if (artifacts.length === 0) return '';

  const lines = artifacts.map((a) => {
    return `### ${a.title} (${a.type})
\`\`\`${a.format}
${a.content}
\`\`\``;
  });

  return `## Implementation Artifacts\n\n${lines.join('\n\n')}`;
}

function buildJiraContextSection(context: DebateContext): string {
  return `## Jira Issue Context
- **Issue Key**: ${context.jiraKey}
- **Summary**: ${context.summary}
${context.description ? `- **Description**: ${context.description}` : ''}
- **Environment**: ${context.env}`;
}

function buildInstructionsSection(env: Environment): string {
  const envRules: string[] = [];

  switch (env) {
    case 'prd':
      envRules.push(
        '- DB 스키마 변경 금지',
        '- console.log/debugger 코드 금지',
        '- 성능 저하 가능성 있는 변경 주의',
        '- 보안 관련 변경은 반드시 리뷰 필요'
      );
      break;
    case 'stg':
      envRules.push(
        '- Force push 금지',
        '- 프로덕션과 동일한 코드 품질 유지'
      );
      break;
    case 'int':
      envRules.push(
        '- 실험적 변경 허용',
        '- 테스트 커버리지 유지'
      );
      break;
  }

  return `## Implementation Instructions

### General Rules
- TypeScript strict mode 준수
- 기존 코드 패턴 및 컨벤션 따르기
- 새 파일 생성 시 기존 구조 참조
- 에러 핸들링 포함
- 변경사항에 대한 테스트 작성

### Environment-Specific Rules (${env})
${envRules.join('\n')}

### Quality Gates
구현 후 다음 게이트가 자동으로 실행됩니다:
1. TypeScript 타입 체크
2. ESLint 검사
3. 단위 테스트
4. 빌드 검증

모든 게이트를 통과해야 PR이 생성됩니다.

## Memory & Learning

After completing each significant decision or implementation step:
1. Use \`mcp__plugin_claude-mem_mcp-search__save_memory\` to persist key learnings
2. Include: what was decided, why, what alternatives were rejected
3. Tag with the Jira key and relevant technology tags

This ensures knowledge accumulates across sessions for this project.`;
}
