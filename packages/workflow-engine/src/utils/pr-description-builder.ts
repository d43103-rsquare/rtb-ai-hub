import type { JiraWebhookEvent, Environment, DebateOutcome } from '@rtb-ai-hub/shared';
import type { FigmaContext } from './figma-context';
import type { CiRunResult } from './target-ci';

// β”€β”€β”€ Types β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€

export type PrDescriptionInput = {
  event: JiraWebhookEvent;
  env: Environment;
  implementation: {
    plan: string;
    files: Array<{ path: string; content: string; action: string }>;
    tests: Array<{ path: string; content: string }>;
    prSuggestion: { title: string; description: string };
  };
  localResults: {
    branchName: string;
    baseBranch: string;
  };
  ciResults: CiRunResult | null;
  figmaContext: FigmaContext | null;
  domainKnowledge: string | undefined;
  previewUrl: string | undefined;
  debateOutcome?: DebateOutcome;
};

// β”€β”€β”€ Constants β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€

const MAX_DESCRIPTION_LENGTH = 500;
const MAX_PLAN_LENGTH = 800;
const MAX_DOMAIN_LENGTH = 500;
const MAX_CI_FAILURE_LENGTH = 1000;
const MAX_DECISION_LENGTH = 600;
const MAX_DISSENTING_VIEW_LENGTH = 200;

const FOOTER = '---\n*Auto-generated by RTB AI Hub (Multi-Agent Pipeline)*';

// β”€β”€β”€ Main Builder β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€

export function buildEnrichedPrDescription(input: PrDescriptionInput): string {
  const { event, implementation } = input;

  const heading = `## ${event.issueKey}: ${event.summary}`;

  const sections = [
    heading,
    buildContextSection(input),
    buildAiRationaleSection(input),
    buildRequirementsSection(input),
    buildImplementationSection(input),
    buildFilesSection(input),
    buildImpactSection(input),
    buildDomainSection(input),
    buildCiSection(input),
    implementation.prSuggestion.description,
    FOOTER,
  ];

  return sections.filter(Boolean).join('\n\n');
}

// β”€β”€β”€ Section Builders β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€

function buildContextSection(input: PrDescriptionInput): string {
  const { event, env, localResults, figmaContext, previewUrl } = input;

  const jiraHost = process.env.JIRA_HOST || '';
  const jiraLink = jiraHost
    ? `[${event.issueKey}](https://${jiraHost}/browse/${event.issueKey})`
    : event.issueKey;

  const rows: Array<[string, string]> = [
    ['Jira', jiraLink],
    ['Environment', env],
    ['Branch', `\`${localResults.branchName}\` β†’ \`${localResults.baseBranch}\``],
  ];

  if (figmaContext?.fileUrl) {
    rows.splice(1, 0, ['Figma', `[Design File](${figmaContext.fileUrl})`]);
  }

  if (previewUrl) {
    rows.push(['Preview', `[Open Preview](${previewUrl})`]);
  }

  const header = '| Item | Link |';
  const separator = '|------|------|';
  const tableRows = rows.map(([item, link]) => `| ${item} | ${link} |`);

  return ['### Context', header, separator, ...tableRows].join('\n');
}

function buildAiRationaleSection(input: PrDescriptionInput): string | null {
  const { debateOutcome } = input;
  if (!debateOutcome) return null;

  const statusLabel: Record<string, string> = {
    consensus: 'πΆ ν•©μ',
    'moderator-decided': 'π΅ μ¤‘μ¬μ κ²°μ •',
    'max-turns-reached': 'π”΄ μµλ€ ν„΄ λ„λ‹¬',
    'budget-exceeded': 'π”΄ μμ‚° μ΄κ³Ό',
    error: 'π”΄ μ¤λ¥',
  };
  const badge = statusLabel[debateOutcome.status] ?? debateOutcome.status;

  const lines = ['### AI Decision Rationale', '', `**κ²°μ • λ°©μ‹**: ${badge}`, ''];

  // Decision summary (strip REVIEW_CHECKPOINTS section before showing)
  const decisionBody = debateOutcome.decision
    .replace(/\n?##\s*REVIEW_CHECKPOINTS[\s\S]*$/, '')
    .trim();
  if (decisionBody) {
    lines.push('**μ„ νƒ μ΄μ **', '', truncate(decisionBody, MAX_DECISION_LENGTH), '');
  }

  // Dissenting views
  if (debateOutcome.dissentingViews && debateOutcome.dissentingViews.length > 0) {
    lines.push('**κ³ λ ¤ν• λ°λ€ μκ²¬**', '');
    for (const { agent, view } of debateOutcome.dissentingViews) {
      lines.push(`> **${agent}**: ${truncate(view, MAX_DISSENTING_VIEW_LENGTH)}`);
    }
    lines.push('');
  }

  // Review checkpoints β€” rendered as GitHub checkboxes
  if (debateOutcome.reviewCheckpoints && debateOutcome.reviewCheckpoints.length > 0) {
    lines.push('**λ¦¬λ·°μ–΄ μ²΄ν¬ν¬μΈνΈ** β€” μ•„λ ν•­λ©μ„ λ°λ“μ‹ ν™•μΈν•κ³  μΉμΈν•΄μ£Όμ„Έμ”', '');
    for (const checkpoint of debateOutcome.reviewCheckpoints) {
      lines.push(`- [ ] ${checkpoint}`);
    }
  }

  return lines.join('\n');
}

function buildRequirementsSection(input: PrDescriptionInput): string | null {
  const description = input.event.description;
  if (!description) return null;

  const truncated = truncate(description, MAX_DESCRIPTION_LENGTH);
  return `### Requirements\n\n${truncated}`;
}

function buildImplementationSection(input: PrDescriptionInput): string | null {
  const plan = input.implementation.plan;
  if (!plan) return null;

  const truncated = truncate(plan, MAX_PLAN_LENGTH);
  return `### Implementation Plan\n\n${truncated}`;
}

function buildFilesSection(input: PrDescriptionInput): string {
  const { files, tests } = input.implementation;

  const fileLines = files.map((f) => `- \`${f.path}\` β€” ${f.action}`);
  const testLines = tests.map((t) => `- \`${t.path}\` β€” test`);

  const allLines = [...fileLines, ...testLines];
  const total = allLines.length;

  return [`### Files Changed (${total})`, ...allLines].join('\n');
}

function buildImpactSection(input: PrDescriptionInput): string {
  const { files, tests } = input.implementation;

  const newFiles = files.filter((f) => f.action === 'add' || f.action === 'create').length;
  const modifiedFiles = files.filter(
    (f) => f.action === 'modify' || f.action === 'update' || f.action === 'edit'
  ).length;
  const testCount = tests.length;

  const directories = new Set<string>();
  for (const f of files) {
    const dir = f.path.includes('/') ? f.path.substring(0, f.path.lastIndexOf('/')) : '.';
    directories.add(dir);
  }
  for (const t of tests) {
    const dir = t.path.includes('/') ? t.path.substring(0, t.path.lastIndexOf('/')) : '.';
    directories.add(dir);
  }

  const lines = [
    '### Impact Analysis',
    '',
    `- **New files**: ${newFiles}`,
    `- **Modified files**: ${modifiedFiles}`,
    `- **Test files**: ${testCount}`,
    '',
    '**Affected directories**:',
    ...[...directories].sort().map((d) => `- \`${d}\``),
  ];

  return lines.join('\n');
}

function buildDomainSection(input: PrDescriptionInput): string | null {
  const { domainKnowledge } = input;
  if (!domainKnowledge) return null;

  const truncated = truncate(domainKnowledge, MAX_DOMAIN_LENGTH);
  const blockquoted = truncated
    .split('\n')
    .map((line) => `> ${line}`)
    .join('\n');

  return `### Domain Knowledge\n\n${blockquoted}`;
}

function buildCiSection(input: PrDescriptionInput): string | null {
  const { ciResults } = input;
  if (!ciResults) return null;

  if (ciResults.success) {
    const stepLines = ciResults.steps.map((s) => `- β… ${s.name} (${s.durationMs}ms)`);
    return [`### CI Status: β… Passed`, '', ...stepLines].join('\n');
  }

  const stepLines = ciResults.steps.map(
    (s) => `- ${s.success ? 'β…' : 'β'} ${s.name} (${s.durationMs}ms)`
  );

  const lines = [`### CI Status: β Failed`, '', ...stepLines];

  if (ciResults.failedStep) {
    const failureOutput = [ciResults.failedStep.stderr, ciResults.failedStep.stdout]
      .filter(Boolean)
      .join('\n');
    const truncatedOutput = truncate(failureOutput, MAX_CI_FAILURE_LENGTH);
    lines.push('', '```', truncatedOutput, '```');
  }

  return lines.join('\n');
}

// β”€β”€β”€ Utilities β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€β”€

function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + '...';
}
