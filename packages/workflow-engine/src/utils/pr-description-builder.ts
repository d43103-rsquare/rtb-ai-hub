import type { JiraWebhookEvent, Environment } from '@rtb-ai-hub/shared';
import type { FigmaContext } from './figma-context';
import type { CiRunResult } from './target-ci';

// ─── Types ──────────────────────────────────────────────────────────────────

export type PrDescriptionInput = {
  event: JiraWebhookEvent;
  env: Environment;
  implementation: {
    plan: string;
    files: Array<{ path: string; content: string; action: string }>;
    tests: Array<{ path: string; content: string }>;
    prSuggestion: { title: string; description: string };
  };
  localResults: {
    branchName: string;
    baseBranch: string;
  };
  ciResults: CiRunResult | null;
  figmaContext: FigmaContext | null;
  domainKnowledge: string | undefined;
  previewUrl: string | undefined;
};

// ─── Constants ──────────────────────────────────────────────────────────────

const MAX_DESCRIPTION_LENGTH = 500;
const MAX_PLAN_LENGTH = 800;
const MAX_DOMAIN_LENGTH = 500;
const MAX_CI_FAILURE_LENGTH = 1000;

const FOOTER = '---\n*Auto-generated by RTB AI Hub (Multi-Agent Pipeline)*';

// ─── Main Builder ───────────────────────────────────────────────────────────

export function buildEnrichedPrDescription(input: PrDescriptionInput): string {
  const { event, implementation } = input;

  const heading = `## ${event.issueKey}: ${event.summary}`;

  const sections = [
    heading,
    buildContextSection(input),
    buildRequirementsSection(input),
    buildImplementationSection(input),
    buildFilesSection(input),
    buildImpactSection(input),
    buildDomainSection(input),
    buildCiSection(input),
    implementation.prSuggestion.description,
    FOOTER,
  ];

  return sections.filter(Boolean).join('\n\n');
}

// ─── Section Builders ───────────────────────────────────────────────────────

function buildContextSection(input: PrDescriptionInput): string {
  const { event, env, localResults, figmaContext, previewUrl } = input;

  const jiraHost = process.env.JIRA_HOST || '';
  const jiraLink = jiraHost
    ? `[${event.issueKey}](https://${jiraHost}/browse/${event.issueKey})`
    : event.issueKey;

  const rows: Array<[string, string]> = [
    ['Jira', jiraLink],
    ['Environment', env],
    ['Branch', `\`${localResults.branchName}\` → \`${localResults.baseBranch}\``],
  ];

  if (figmaContext?.fileUrl) {
    rows.splice(1, 0, ['Figma', `[Design File](${figmaContext.fileUrl})`]);
  }

  if (previewUrl) {
    rows.push(['Preview', `[Open Preview](${previewUrl})`]);
  }

  const header = '| Item | Link |';
  const separator = '|------|------|';
  const tableRows = rows.map(([item, link]) => `| ${item} | ${link} |`);

  return ['### Context', header, separator, ...tableRows].join('\n');
}

function buildRequirementsSection(input: PrDescriptionInput): string | null {
  const description = input.event.description;
  if (!description) return null;

  const truncated = truncate(description, MAX_DESCRIPTION_LENGTH);
  return `### Requirements\n\n${truncated}`;
}

function buildImplementationSection(input: PrDescriptionInput): string | null {
  const plan = input.implementation.plan;
  if (!plan) return null;

  const truncated = truncate(plan, MAX_PLAN_LENGTH);
  return `### Implementation Plan\n\n${truncated}`;
}

function buildFilesSection(input: PrDescriptionInput): string {
  const { files, tests } = input.implementation;

  const fileLines = files.map((f) => `- \`${f.path}\` — ${f.action}`);
  const testLines = tests.map((t) => `- \`${t.path}\` — test`);

  const allLines = [...fileLines, ...testLines];
  const total = allLines.length;

  return [`### Files Changed (${total})`, ...allLines].join('\n');
}

function buildImpactSection(input: PrDescriptionInput): string {
  const { files, tests } = input.implementation;

  const newFiles = files.filter((f) => f.action === 'add' || f.action === 'create').length;
  const modifiedFiles = files.filter(
    (f) => f.action === 'modify' || f.action === 'update' || f.action === 'edit'
  ).length;
  const testCount = tests.length;

  const directories = new Set<string>();
  for (const f of files) {
    const dir = f.path.includes('/') ? f.path.substring(0, f.path.lastIndexOf('/')) : '.';
    directories.add(dir);
  }
  for (const t of tests) {
    const dir = t.path.includes('/') ? t.path.substring(0, t.path.lastIndexOf('/')) : '.';
    directories.add(dir);
  }

  const lines = [
    '### Impact Analysis',
    '',
    `- **New files**: ${newFiles}`,
    `- **Modified files**: ${modifiedFiles}`,
    `- **Test files**: ${testCount}`,
    '',
    '**Affected directories**:',
    ...[...directories].sort().map((d) => `- \`${d}\``),
  ];

  return lines.join('\n');
}

function buildDomainSection(input: PrDescriptionInput): string | null {
  const { domainKnowledge } = input;
  if (!domainKnowledge) return null;

  const truncated = truncate(domainKnowledge, MAX_DOMAIN_LENGTH);
  const blockquoted = truncated
    .split('\n')
    .map((line) => `> ${line}`)
    .join('\n');

  return `### Domain Knowledge\n\n${blockquoted}`;
}

function buildCiSection(input: PrDescriptionInput): string | null {
  const { ciResults } = input;
  if (!ciResults) return null;

  if (ciResults.success) {
    const stepLines = ciResults.steps.map((s) => `- ✅ ${s.name} (${s.durationMs}ms)`);
    return [`### CI Status: ✅ Passed`, '', ...stepLines].join('\n');
  }

  const stepLines = ciResults.steps.map(
    (s) => `- ${s.success ? '✅' : '❌'} ${s.name} (${s.durationMs}ms)`
  );

  const lines = [`### CI Status: ❌ Failed`, '', ...stepLines];

  if (ciResults.failedStep) {
    const failureOutput = [ciResults.failedStep.stderr, ciResults.failedStep.stdout]
      .filter(Boolean)
      .join('\n');
    const truncatedOutput = truncate(failureOutput, MAX_CI_FAILURE_LENGTH);
    lines.push('', '```', truncatedOutput, '```');
  }

  return lines.join('\n');
}

// ─── Utilities ──────────────────────────────────────────────────────────────

function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + '...';
}
