# Active Wiki Facilitation & Onboarding Coordination Design

## 1. Active Wiki Facilitation

### 1.1 ê°œìš”

Active Wiki Facilitationì€ ê¸°ì¡´ì˜ **ìˆ˜ë™ì  Wiki ì°¸ì¡°**ì—ì„œ ë²—ì–´ë‚˜, **ëŠ¥ë™ì ìœ¼ë¡œ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ì„ ì§€ì›**í•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤. ëŒ€í™”/ì‘ì—…ì˜ ë§¥ë½ì„ ì´í•´í•˜ê³  ì ì ˆí•œ ì‹œì ì— ê´€ë ¨ ì§€ì‹ì„ ì œì•ˆí•©ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Active Wiki Facilitation System                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   Trigger Sources                    Processing Pipeline                     â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                    â”‚
â”‚   â”‚   Slack      â”‚â”€â”€â”                                              â”‚
â”‚   â”‚   Message    â”‚  â”‚                                              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                     â”‚    â”‚      Context Analysis Engine        â”‚   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚                                     â”‚   â”‚
â”‚   â”‚   Jira       â”‚â”€â”€â”¼â”€â”€â”€â–¶â”‚  - Intent Classification            â”‚   â”‚
â”‚   â”‚   Comment    â”‚  â”‚    â”‚  - Entity Extraction                â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  - Role Identification              â”‚   â”‚
â”‚                     â”‚    â”‚  - Knowledge Gap Detection          â”‚   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚   â”‚   PR Review  â”‚â”€â”€â”˜                   â”‚                          â”‚
â”‚   â”‚   Comment    â”‚                      â–¼                          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚                            â”‚    Suggestion Engine         â”‚        â”‚
â”‚                            â”‚                              â”‚        â”‚
â”‚                            â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚
â”‚                            â”‚  â”‚ Relevanceâ”‚ â”‚ Priority â”‚  â”‚        â”‚
â”‚                            â”‚  â”‚ Scoring  â”‚ â”‚ Ranking  â”‚  â”‚        â”‚
â”‚                            â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚
â”‚                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                           â”‚                        â”‚
â”‚                                           â–¼                        â”‚
â”‚                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚                            â”‚   Delivery Strategy          â”‚        â”‚
â”‚                            â”‚                              â”‚        â”‚
â”‚                            â”‚  - Inline suggestion         â”‚        â”‚
â”‚                            â”‚  - Thread reply              â”‚        â”‚
â”‚                            â”‚  - DM notification           â”‚        â”‚
â”‚                            â”‚  - Dashboard widget          â”‚        â”‚
â”‚                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                           â”‚                        â”‚
â”‚                                           â–¼                        â”‚
â”‚   Output                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚                                  â”‚  Wiki Content   â”‚               â”‚
â”‚   ğŸ’¡ "ì´ ëŒ€í™”ì—ì„œ 'JWT ì¸ì¦'ì—   â”‚  - Extracts     â”‚               â”‚
â”‚       ê´€ë ¨ëœ wiki ë¬¸ì„œë¥¼         â”‚  - Summarizes   â”‚               â”‚
â”‚       ì°¾ì•˜ìŠµë‹ˆë‹¤: auth/jwt.md"   â”‚  - Contextualizesâ”‚              â”‚
â”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 íƒ€ì… ì •ì˜

```typescript
// packages/shared/src/communication-types.ts (append)

/**
 * Wiki Facilitation Trigger
 */
export interface WikiFacilitationTrigger {
  id: string;
  source: 'slack' | 'jira' | 'github' | 'manual';
  sourceId: string; // message id, issue key, etc.
  content: {
    text: string;
    author: {
      userId: string;
      role: ExtendedTeamRole;
    };
    timestamp: Date;
    threadContext?: string[]; // ì´ì „ ëŒ€í™” ë§¥ë½
  };
  context: {
    jiraKey?: string;
    project?: string;
    participants: ExtendedTeamRole[];
  };
}

/**
 * Wiki Suggestion
 */
export interface WikiSuggestion {
  id: string;
  triggerId: string;

  // ì œì•ˆëœ ë¬¸ì„œ
  document: {
    path: string;
    title: string;
    summary: string;
    relevanceScore: number; // 0-1
    keySections: WikiSection[];
  };

  // ì œì•ˆ ê·¼ê±°
  reasoning: {
    matchedKeywords: string[];
    matchedConcepts: string[];
    contextGaps: string[]; // ì´ ì§€ì‹ì´ ì±„ì›Œì£¼ëŠ” ê²©ì°¨
    relatedDiscussions: string[];
  };

  // í‘œì‹œ ì„¤ì •
  presentation: {
    urgency: 'immediate' | 'helpful' | 'reference';
    format: 'inline' | 'sidebar' | 'popup' | 'digest';
    includeFullText: boolean;
    includeSummary: boolean;
    includeLinks: boolean;
  };

  // ë©”íƒ€ë°ì´í„°
  metadata: {
    suggestedAt: Date;
    deliveredAt?: Date;
    acknowledgedAt?: Date;
    feedback?: 'helpful' | 'not-relevant' | 'already-known';
  };
}

/**
 * Wiki Section
 */
export interface WikiSection {
  heading: string;
  content: string;
  relevanceScore: number;
  lineNumbers: { start: number; end: number };
}

/**
 * Knowledge Gap
 */
export interface KnowledgeGap {
  id: string;
  detectedIn: string; // message id, discussion id

  // ê²©ì°¨ ë‚´ìš©
  gap: {
    type: 'missing-domain' | 'missing-technical' | 'ambiguous-term' | 'outdated-info';
    description: string;
    affectedRoles: ExtendedTeamRole[];
    severity: 'critical' | 'high' | 'medium' | 'low';
  };

  // ê´€ë ¨ ì •ë³´
  relatedWikiDocs: string[];
  relatedDiscussions: string[];
  suggestedResolution: string;

  // ìƒíƒœ
  status: 'detected' | 'suggested' | 'acknowledged' | 'resolved' | 'ignored';
}

/**
 * Concept Relationship
 */
export interface ConceptRelationship {
  sourceConcept: string;
  targetConcept: string;
  relationship: 'depends-on' | 'uses' | 'implements' | 'extends' | 'related-to';
  strength: number; // 0-1
  evidence: string[]; // ì¶œì²˜ ë¬¸ì„œë“¤
}

/**
 * Concept Map
 */
export interface ConceptMap {
  rootConcept: string;
  nodes: ConceptNode[];
  edges: ConceptEdge[];
}

export interface ConceptNode {
  id: string;
  concept: string;
  category: ConceptCategory;
  wikiPath: string;
  importance: number;
}

export interface ConceptEdge {
  from: string;
  to: string;
  relationship: string;
  strength: number;
}
```

### 1.3 Facilitator Service Implementation

```typescript
// packages/workflow-engine/src/communication/wiki-facilitator/facilitator-service.ts

import { createLogger } from '@rtb-ai-hub/shared';
import type {
  WikiFacilitationTrigger,
  WikiSuggestion,
  KnowledgeGap,
  ConceptMap,
} from '@rtb-ai-hub/shared';
import { WikiKnowledge } from '../../utils/wiki-knowledge';
import { SuggestionEngine } from './suggestion-engine';
import { GapDetector } from './gap-detector';
import { ConceptMapper } from './concept-mapper';

const logger = createLogger('wiki-facilitator');

export class WikiFacilitationService {
  private wikiKnowledge: WikiKnowledge;
  private suggestionEngine: SuggestionEngine;
  private gapDetector: GapDetector;
  private conceptMapper: ConceptMapper;

  constructor(wikiPath: string) {
    this.wikiKnowledge = new WikiKnowledge(wikiPath);
    this.suggestionEngine = new SuggestionEngine(this.wikiKnowledge);
    this.gapDetector = new GapDetector(this.wikiKnowledge);
    this.conceptMapper = new ConceptMapper(this.wikiKnowledge);
  }

  /**
   * ì»¨í…ìŠ¤íŠ¸ ë¶„ì„ ë° ì œì•ˆ ìƒì„±
   */
  async analyzeAndSuggest(trigger: WikiFacilitationTrigger): Promise<{
    suggestions: WikiSuggestion[];
    gaps: KnowledgeGap[];
  }> {
    logger.info({ triggerId: trigger.id }, 'Analyzing context for wiki suggestions');

    // 1. ì»¨í…ìŠ¤íŠ¸ ë¶„ì„
    const context = await this.analyzeContext(trigger);

    // 2. ê´€ë ¨ ë¬¸ì„œ ê²€ìƒ‰
    const relevantDocs = await this.findRelevantDocuments(context);

    // 3. ì§€ì‹ ê²©ì°¨ ê°ì§€
    const gaps = await this.gapDetector.detect(context, relevantDocs);

    // 4. ì œì•ˆ ìƒì„±
    const suggestions = await this.suggestionEngine.generate(trigger, context, relevantDocs, gaps);

    // 5. ìˆœìœ„ ê²°ì •
    const rankedSuggestions = this.rankSuggestions(suggestions, context);

    logger.info(
      {
        triggerId: trigger.id,
        suggestionCount: rankedSuggestions.length,
        gapCount: gaps.length,
      },
      'Wiki analysis completed'
    );

    return {
      suggestions: rankedSuggestions,
      gaps,
    };
  }

  /**
   * ì»¨í…ìŠ¤íŠ¸ ë¶„ì„
   */
  private async analyzeContext(trigger: WikiFacilitationTrigger): Promise<AnalyzedContext> {
    const { content, context } = trigger;

    // í‚¤ì›Œë“œ ì¶”ì¶œ
    const keywords = this.extractKeywords(content.text);

    // ë„ë©”ì¸ ê°œë… ì‹ë³„
    const concepts = await this.identifyConcepts(content.text);

    // ì˜ë„ ë¶„ë¥˜
    const intent = this.classifyIntent(content.text);

    // ì°¸ì—¬ìë³„ í•„ìš” ì§€ì‹
    const knowledgeNeeds = this.assessKnowledgeNeeds(context.participants, concepts);

    return {
      keywords,
      concepts,
      intent,
      knowledgeNeeds,
      threadContext: content.threadContext || [],
    };
  }

  /**
   * ê´€ë ¨ ë¬¸ì„œ ê²€ìƒ‰
   */
  private async findRelevantDocuments(context: AnalyzedContext): Promise<RelevantDocument[]> {
    const docs: RelevantDocument[] = [];

    // í‚¤ì›Œë“œ ê¸°ë°˜ ê²€ìƒ‰
    for (const keyword of context.keywords) {
      const matches = await this.wikiKnowledge.searchByKeyword(keyword);
      docs.push(...matches);
    }

    // ê°œë… ê¸°ë°˜ ê²€ìƒ‰
    for (const concept of context.concepts) {
      const matches = await this.wikiKnowledge.searchByConcept(concept.id);
      docs.push(...matches);
    }

    // ì¤‘ë³µ ì œê±° ë° ìˆœìœ„ ê²°ì •
    const uniqueDocs = this.deduplicateAndRank(docs, context);

    return uniqueDocs.slice(0, 5); // ìƒìœ„ 5ê°œë§Œ
  }

  /**
   * ì œì•ˆ ìˆœìœ„ ê²°ì •
   */
  private rankSuggestions(
    suggestions: WikiSuggestion[],
    context: AnalyzedContext
  ): WikiSuggestion[] {
    return suggestions
      .map((s) => ({
        ...s,
        finalScore: this.calculateFinalScore(s, context),
      }))
      .sort((a, b) => b.finalScore - a.finalScore);
  }

  private calculateFinalScore(suggestion: WikiSuggestion, context: AnalyzedContext): number {
    const baseScore = suggestion.document.relevanceScore;

    // ê¸´ê¸‰ë„ ê°€ì¤‘ì¹˜
    const urgencyMultiplier = {
      immediate: 1.5,
      helpful: 1.0,
      reference: 0.7,
    }[suggestion.presentation.urgency];

    // ì´ì „ì— ì–¸ê¸‰ëœ ì  ì—†ëŠ”ì§€ í™•ì¸
    const isNew = !context.threadContext.some((ctx) => ctx.includes(suggestion.document.title));
    const noveltyBonus = isNew ? 1.2 : 0.8;

    return baseScore * urgencyMultiplier * noveltyBonus;
  }

  /**
   * ê°œë… ê´€ê³„ë§µ ìƒì„±
   */
  async generateConceptMap(rootConcept: string, depth: number = 2): Promise<ConceptMap> {
    return this.conceptMapper.generateMap(rootConcept, depth);
  }

  /**
   * ì‹¤ì‹œê°„ ì œì•ˆ (ìŠ¤íŠ¸ë¦¬ë°)
   */
  async *streamSuggestions(
    trigger: WikiFacilitationTrigger,
    options: {
      maxSuggestions: number;
      minRelevance: number;
    }
  ): AsyncGenerator<WikiSuggestion, void, unknown> {
    const { suggestions } = await this.analyzeAndSuggest(trigger);

    for (const suggestion of suggestions) {
      if (suggestion.document.relevanceScore >= options.minRelevance) {
        yield suggestion;
      }

      if (options.maxSuggestions-- <= 0) break;
    }
  }

  // Helper methods
  private extractKeywords(text: string): string[] {
    // í‚¤ì›Œë“œ ì¶”ì¶œ ë¡œì§
    const tablePattern = /\b(obj|prd|mbr|gtd|com)_[a-z0-9_]+\b/gi;
    const techPattern = /\b(API|JWT|OAuth|DB|SQL|HTTP)\b/gi;

    const keywords = new Set<string>();

    let match;
    while ((match = tablePattern.exec(text)) !== null) {
      keywords.add(match[0].toLowerCase());
    }
    while ((match = techPattern.exec(text)) !== null) {
      keywords.add(match[0].toLowerCase());
    }

    return Array.from(keywords);
  }

  private async identifyConcepts(text: string): Promise<ConceptReference[]> {
    // ê°œë… ì‹ë³„ ë¡œì§
    return [];
  }

  private classifyIntent(text: string): ContextIntent {
    // ì˜ë„ ë¶„ë¥˜
    if (text.includes('?') || text.includes('ì–´ë–»ê²Œ') || text.includes('ë¬´ì—‡')) {
      return 'question';
    }
    if (text.includes('êµ¬í˜„') || text.includes('ê°œë°œ') || text.includes('ë§Œë“¤')) {
      return 'implementation';
    }
    if (text.includes('ë¬¸ì œ') || text.includes('ì˜¤ë¥˜') || text.includes('ë²„ê·¸')) {
      return 'troubleshooting';
    }
    return 'discussion';
  }

  private assessKnowledgeNeeds(
    participants: ExtendedTeamRole[],
    concepts: ConceptReference[]
  ): Map<ExtendedTeamRole, string[]> {
    // ì—­í• ë³„ í•„ìš” ì§€ì‹ í‰ê°€
    return new Map();
  }

  private deduplicateAndRank(
    docs: RelevantDocument[],
    context: AnalyzedContext
  ): RelevantDocument[] {
    const seen = new Set<string>();
    return docs
      .filter((d) => {
        if (seen.has(d.path)) return false;
        seen.add(d.path);
        return true;
      })
      .sort((a, b) => b.relevanceScore - a.relevanceScore);
  }
}

// Types
interface AnalyzedContext {
  keywords: string[];
  concepts: ConceptReference[];
  intent: ContextIntent;
  knowledgeNeeds: Map<ExtendedTeamRole, string[]>;
  threadContext: string[];
}

interface RelevantDocument {
  path: string;
  title: string;
  relevanceScore: number;
  matchedKeywords: string[];
}

interface ConceptReference {
  id: string;
  name: string;
  confidence: number;
}

type ContextIntent = 'question' | 'implementation' | 'troubleshooting' | 'discussion';
```

### 1.4 Suggestion Engine

```typescript
// packages/workflow-engine/src/communication/wiki-facilitator/suggestion-engine.ts

import { createLogger } from '@rtb-ai-hub/shared';
import type {
  WikiFacilitationTrigger,
  WikiSuggestion,
  KnowledgeGap,
  RelevantDocument,
} from '@rtb-ai-hub/shared';

const logger = createLogger('suggestion-engine');

export class SuggestionEngine {
  constructor(private wikiKnowledge: WikiKnowledge) {}

  /**
   * ì œì•ˆ ìƒì„±
   */
  async generate(
    trigger: WikiFacilitationTrigger,
    context: AnalyzedContext,
    relevantDocs: RelevantDocument[],
    gaps: KnowledgeGap[]
  ): Promise<WikiSuggestion[]> {
    const suggestions: WikiSuggestion[] = [];

    for (const doc of relevantDocs) {
      // ë¬¸ì„œ ë‚´ìš© ë¡œë“œ
      const content = await this.wikiKnowledge.getTableDoc(
        doc.path.split('/').pop()?.replace('.md', '') || ''
      );

      if (!content) continue;

      // ê´€ë ¨ ì„¹ì…˜ ì¶”ì¶œ
      const keySections = this.extractRelevantSections(content, context);

      // ì œì•ˆ ìƒì„±
      const suggestion = this.buildSuggestion(trigger, doc, keySections, context, gaps);

      suggestions.push(suggestion);
    }

    return suggestions;
  }

  /**
   * ê´€ë ¨ ì„¹ì…˜ ì¶”ì¶œ
   */
  private extractRelevantSections(content: string, context: AnalyzedContext): WikiSection[] {
    const sections: WikiSection[] = [];
    const lines = content.split('\n');

    let currentSection: WikiSection | null = null;
    let sectionContent: string[] = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // ì„¹ì…˜ í—¤ë”© ê°ì§€ (##, ###)
      if (line.startsWith('##')) {
        if (currentSection) {
          currentSection.content = sectionContent.join('\n');
          currentSection.relevanceScore = this.calculateSectionRelevance(currentSection, context);
          sections.push(currentSection);
        }

        currentSection = {
          heading: line.replace(/#/g, '').trim(),
          content: '',
          relevanceScore: 0,
          lineNumbers: { start: i, end: i },
        };
        sectionContent = [];
      } else if (currentSection) {
        sectionContent.push(line);
        currentSection.lineNumbers.end = i;
      }
    }

    // ë§ˆì§€ë§‰ ì„¹ì…˜ ì²˜ë¦¬
    if (currentSection) {
      currentSection.content = sectionContent.join('\n');
      currentSection.relevanceScore = this.calculateSectionRelevance(currentSection, context);
      sections.push(currentSection);
    }

    // ìƒìœ„ 3ê°œ ì„¹ì…˜ë§Œ ë°˜í™˜
    return sections.sort((a, b) => b.relevanceScore - a.relevanceScore).slice(0, 3);
  }

  /**
   * ì„¹ì…˜ ê´€ë ¨ì„± ê³„ì‚°
   */
  private calculateSectionRelevance(section: WikiSection, context: AnalyzedContext): number {
    let score = 0;
    const text = (section.heading + ' ' + section.content).toLowerCase();

    // í‚¤ì›Œë“œ ë§¤ì¹­
    for (const keyword of context.keywords) {
      if (text.includes(keyword.toLowerCase())) {
        score += 0.3;
      }
    }

    // ê°œë… ë§¤ì¹­
    for (const concept of context.concepts) {
      if (text.includes(concept.name.toLowerCase())) {
        score += 0.5;
      }
    }

    return Math.min(score, 1.0);
  }

  /**
   * ì œì•ˆ ê°ì²´ ìƒì„±
   */
  private buildSuggestion(
    trigger: WikiFacilitationTrigger,
    doc: RelevantDocument,
    keySections: WikiSection[],
    context: AnalyzedContext,
    gaps: KnowledgeGap[]
  ): WikiSuggestion {
    // ê¸´ê¸‰ë„ ê²°ì •
    const urgency = this.determineUrgency(doc, context, gaps);

    // í‘œì‹œ í˜•ì‹ ê²°ì •
    const format = this.determineFormat(trigger, urgency);

    // ìš”ì•½ ìƒì„±
    const summary = this.generateSummary(doc, keySections);

    return {
      id: generateId('suggest'),
      triggerId: trigger.id,
      document: {
        path: doc.path,
        title: doc.title,
        summary,
        relevanceScore: doc.relevanceScore,
        keySections,
      },
      reasoning: {
        matchedKeywords: doc.matchedKeywords,
        matchedConcepts: context.concepts.map((c) => c.name),
        contextGaps: gaps.map((g) => g.gap.description),
        relatedDiscussions: [],
      },
      presentation: {
        urgency,
        format,
        includeFullText: false,
        includeSummary: true,
        includeLinks: true,
      },
      metadata: {
        suggestedAt: new Date(),
      },
    };
  }

  /**
   * ê¸´ê¸‰ë„ ê²°ì •
   */
  private determineUrgency(
    doc: RelevantDocument,
    context: AnalyzedContext,
    gaps: KnowledgeGap[]
  ): WikiSuggestion['presentation']['urgency'] {
    // ì¤‘ìš”í•œ ê²©ì°¨ë¥¼ ì±„ìš°ëŠ” ë¬¸ì„œ
    const fillsCriticalGap = gaps.some(
      (g) => g.gap.severity === 'critical' && g.relatedWikiDocs.includes(doc.path)
    );
    if (fillsCriticalGap) return 'immediate';

    // ì§ˆë¬¸ì— ì§ì ‘ ê´€ë ¨
    if (context.intent === 'question' && doc.relevanceScore > 0.8) {
      return 'immediate';
    }

    // êµ¬í˜„ ê´€ë ¨
    if (context.intent === 'implementation' && doc.relevanceScore > 0.7) {
      return 'helpful';
    }

    return 'reference';
  }

  /**
   * í‘œì‹œ í˜•ì‹ ê²°ì •
   */
  private determineFormat(
    trigger: WikiFacilitationTrigger,
    urgency: WikiSuggestion['presentation']['urgency']
  ): WikiSuggestion['presentation']['format'] {
    if (trigger.source === 'slack') {
      return urgency === 'immediate' ? 'inline' : 'thread';
    }
    if (trigger.source === 'jira') {
      return 'sidebar';
    }
    return 'reference';
  }

  /**
   * ìš”ì•½ ìƒì„±
   */
  private generateSummary(doc: RelevantDocument, keySections: WikiSection[]): string {
    const sectionSummaries = keySections
      .slice(0, 2)
      .map((s) => `${s.heading}: ${s.content.slice(0, 100)}...`)
      .join('\n');

    return `ê´€ë ¨ ì„¹ì…˜:\n${sectionSummaries}`;
  }
}
```

---

## 2. Onboarding Coordination

### 2.1 ê°œìš”

Onboarding Coordinationì€ ì‹ ê·œ íŒ€ì›ì´ **íš¨ê³¼ì ìœ¼ë¡œ ì ì‘**í•  ìˆ˜ ìˆë„ë¡ êµ¬ì¡°í™”ëœ í•™ìŠµ ê²½ë¡œ, ë§¥ë½ ê¸°ë°˜ ë„ì›€, ë©˜í† ë§ ì‹œìŠ¤í…œì„ ì œê³µí•©ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Onboarding Coordination System                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                    Onboarding Journey Map                           â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   Day 1-3              Week 1              Week 2-4     Month 1-3   â”‚   â”‚
â”‚   â”‚      â”‚                    â”‚                   â”‚            â”‚         â”‚   â”‚
â”‚   â”‚      â–¼                    â–¼                   â–¼            â–¼         â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”     â”‚   â”‚
â”‚   â”‚   â”‚Setup â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚Domainâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚Hands-â”‚â”€â”€â”€â”€â”€â–¶â”‚Indep-â”‚     â”‚   â”‚
â”‚   â”‚   â”‚& Env â”‚            â”‚Knowledge        â”‚ on     â”‚      â”‚endentâ”‚     â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”˜     â”‚   â”‚
â”‚   â”‚      â”‚                    â”‚                   â”‚            â”‚         â”‚   â”‚
â”‚   â”‚      â–¼                    â–¼                   â–¼            â–¼         â”‚   â”‚
â”‚   â”‚   - ê³„ì • ìƒì„±         - ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸   - ì²« í‹°ì¼“     - ë…ë¦½ì       â”‚   â”‚
â”‚   â”‚   - ê°œë°œ í™˜ê²½         - ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜   - ì½”ë“œ ë¦¬ë·°   - í”„ë¡œì íŠ¸    â”‚   â”‚
â”‚   â”‚   - íŒ€ ì†Œê°œ          - ì½”ë”© í‘œì¤€         - Pair      - ë©˜í† ë§       â”‚   â”‚
â”‚   â”‚                      - Git ì „ëµ           í”„ë¡œê·¸ë˜ë°    - ì™„ë£Œ        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                    Key Components                                   â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚   â”‚
â”‚   â”‚  â”‚   Learning   â”‚  â”‚   Contextual â”‚  â”‚   Mentor     â”‚               â”‚   â”‚
â”‚   â”‚  â”‚    Path      â”‚  â”‚     Help     â”‚  â”‚   Matching   â”‚               â”‚   â”‚
â”‚   â”‚  â”‚  Generator   â”‚  â”‚   System     â”‚  â”‚   Engine     â”‚               â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚   â”‚
â”‚   â”‚         â”‚                â”‚                â”‚                         â”‚   â”‚
â”‚   â”‚         â–¼                â–¼                â–¼                         â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚   â”‚  â”‚                    Progress Tracker                          â”‚  â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 íƒ€ì… ì •ì˜

```typescript
// packages/shared/src/communication-types.ts (append)

/**
 * Onboarding Plan
 */
export interface OnboardingPlan {
  id: string;
  userId: string;
  role: ExtendedTeamRole;

  // ê¸°ë³¸ ì •ë³´
  startDate: Date;
  expectedEndDate: Date;

  // ë‹¨ê³„ë³„ ê³„íš
  phases: OnboardingPhase[];

  // ì§„í–‰ ìƒí™©
  progress: {
    completedSteps: number;
    totalSteps: number;
    currentPhase: string;
    overallProgress: number; // 0-100
  };

  // ë©˜í† ë§
  mentor?: {
    userId: string;
    role: ExtendedTeamRole;
    assignedAt: Date;
  };

  // ì„¤ì •
  config: {
    pace: 'standard' | 'accelerated' | 'extended';
    focusAreas: string[];
    skipIfKnown: boolean;
  };
}

/**
 * Onboarding Phase
 */
export interface OnboardingPhase {
  id: string;
  name: string;
  order: number;

  // ê¸°ê°„
  durationDays: number;
  startDate?: Date;
  endDate?: Date;

  // í•™ìŠµ ë‹¨ê³„
  steps: OnboardingStep[];

  // ì™„ë£Œ ê¸°ì¤€
  completionCriteria: CompletionCriterion[];

  // ìƒíƒœ
  status: 'pending' | 'in-progress' | 'completed' | 'skipped';
}

/**
 * Onboarding Step
 */
export interface OnboardingStep {
  id: string;
  name: string;
  type: 'reading' | 'video' | 'interactive' | 'task' | 'meeting' | 'shadowing';

  // ì½˜í…ì¸ 
  content: {
    title: string;
    description: string;
    resources: ResourceReference[];
    estimatedDurationMinutes: number;
  };

  // ì™„ë£Œ ì¡°ê±´
  completion: {
    type: 'self-check' | 'quiz' | 'task-completion' | 'mentor-approval';
    requirements: string[];
  };

  // ìƒíƒœ
  status: 'not-started' | 'in-progress' | 'completed';
  startedAt?: Date;
  completedAt?: Date;
}

/**
 * Resource Reference
 */
export interface ResourceReference {
  type: 'wiki' | 'document' | 'video' | 'code' | 'ticket' | 'person';
  title: string;
  url?: string;
  description?: string;
}

/**
 * Contextual Help Request
 */
export interface ContextualHelpRequest {
  id: string;
  userId: string;
  role: ExtendedTeamRole;

  // ì»¨í…ìŠ¤íŠ¸
  context: {
    currentTask?: string;
    currentFile?: string;
    currentTicket?: string;
    errorMessage?: string;
    codeSnippet?: string;
  };

  // ì§ˆë¬¸
  question: string;

  // ê¸´ê¸‰ë„
  urgency: 'blocking' | 'helpful' | 'curiosity';
}

/**
 * Contextual Help Response
 */
export interface ContextualHelpResponse {
  requestId: string;

  // ì‘ë‹µ
  answer: string;

  // ê´€ë ¨ ë¦¬ì†ŒìŠ¤
  resources: ResourceReference[];

  // ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ
  nextSteps: string[];

  // ê´€ë ¨ íŒ€ì›
  suggestedPeople: {
    userId: string;
    role: ExtendedTeamRole;
    reason: string;
  }[];

  // í•™ìŠµ ê¸°íšŒ
  learningOpportunity?: {
    concept: string;
    wikiPath: string;
    importance: 'critical' | 'recommended' | 'optional';
  };
}

/**
 * Mentor Profile
 */
export interface MentorProfile {
  userId: string;
  role: ExtendedTeamRole;

  // ì „ë¬¸ì„±
  expertise: {
    domains: string[];
    technologies: string[];
    yearsOfExperience: number;
  };

  // ë©˜í† ë§ ê²½í—˜
  mentoring: {
    totalMentees: number;
    currentMentees: number;
    averageRating: number;
    preferredMenteeRoles: ExtendedTeamRole[];
  };

  // ê°€ìš©ì„±
  availability: {
    maxMentees: number;
    preferredMeetingTimes: string[];
    timezone: string;
  };

  // ìƒíƒœ
  isAvailable: boolean;
}

/**
 * Mentorship Match
 */
export interface MentorshipMatch {
  mentorId: string;
  menteeId: string;

  // ë§¤ì¹­ ì ìˆ˜
  score: number;

  // ë§¤ì¹­ ê·¼ê±°
  reasoning: {
    roleAlignment: number;
    expertiseOverlap: string[];
    availabilityMatch: boolean;
    pastCollaboration?: boolean;
  };

  // ê¶Œì¥ ì‚¬í•­
  recommendations: {
    meetingFrequency: string;
    focusAreas: string[];
    suggestedActivities: string[];
  };
}
```

### 2.3 Onboarding Service

```typescript
// packages/workflow-engine/src/communication/onboarding/onboarding-service.ts

import { createLogger } from '@rtb-ai-hub/shared';
import type {
  OnboardingPlan,
  OnboardingPhase,
  OnboardingStep,
  ExtendedTeamRole,
  ContextualHelpRequest,
  ContextualHelpResponse,
} from '@rtb-ai-hub/shared';
import { PathGenerator } from './path-generator';
import { MentorMatcher } from './mentor-matcher';
import { ProgressTracker } from './progress-tracker';
import { WikiKnowledge } from '../../utils/wiki-knowledge';

const logger = createLogger('onboarding-service');

export class OnboardingService {
  private pathGenerator: PathGenerator;
  private mentorMatcher: MentorMatcher;
  private progressTracker: ProgressTracker;
  private wikiKnowledge: WikiKnowledge;

  constructor(wikiPath: string) {
    this.pathGenerator = new PathGenerator(wikiPath);
    this.mentorMatcher = new MentorMatcher();
    this.progressTracker = new ProgressTracker();
    this.wikiKnowledge = new WikiKnowledge(wikiPath);
  }

  /**
   * ì˜¨ë³´ë”© í”Œëœ ìƒì„±
   */
  async createOnboardingPlan(
    userId: string,
    role: ExtendedTeamRole,
    options: {
      startDate: Date;
      pace?: 'standard' | 'accelerated' | 'extended';
      priorExperience?: string[];
    }
  ): Promise<OnboardingPlan> {
    logger.info({ userId, role }, 'Creating onboarding plan');

    // í•™ìŠµ ê²½ë¡œ ìƒì„±
    const phases = await this.pathGenerator.generate(
      role,
      options.pace || 'standard',
      options.priorExperience
    );

    // ë©˜í†  ë§¤ì¹­
    const mentorMatch = await this.mentorMatcher.findBestMatch(userId, role);

    // í”Œëœ ìƒì„±
    const plan: OnboardingPlan = {
      id: generateId('onboard'),
      userId,
      role,
      startDate: options.startDate,
      expectedEndDate: this.calculateEndDate(options.startDate, phases),
      phases,
      progress: {
        completedSteps: 0,
        totalSteps: phases.reduce((sum, p) => sum + p.steps.length, 0),
        currentPhase: phases[0]?.id || '',
        overallProgress: 0,
      },
      mentor: mentorMatch
        ? {
            userId: mentorMatch.mentorId,
            role,
            assignedAt: new Date(),
          }
        : undefined,
      config: {
        pace: options.pace || 'standard',
        focusAreas: [],
        skipIfKnown: true,
      },
    };

    // DB ì €ì¥
    await this.persistPlan(plan);

    logger.info({ planId: plan.id }, 'Onboarding plan created');

    return plan;
  }

  /**
   * ë§¥ë½ ê¸°ë°˜ ë„ì›€ ì œê³µ
   */
  async provideContextualHelp(request: ContextualHelpRequest): Promise<ContextualHelpResponse> {
    logger.info({ userId: request.userId }, 'Providing contextual help');

    // ê´€ë ¨ wiki ë¬¸ì„œ ê²€ìƒ‰
    const wikiContext = await this.wikiKnowledge.searchForContext(
      `${request.question} ${request.context.currentTask || ''}`,
      3
    );

    // ìœ ì‚¬í•œ ê³¼ê±° ì§ˆë¬¸ ê²€ìƒ‰
    const similarQuestions = await this.findSimilarQuestions(request);

    // íŒ€ì› ì¶”ì²œ
    const suggestedPeople = await this.suggestPeople(request);

    // ì‘ë‹µ ìƒì„±
    const response: ContextualHelpResponse = {
      requestId: request.id,
      answer: this.generateAnswer(request, wikiContext, similarQuestions),
      resources: this.extractResources(wikiContext),
      nextSteps: this.suggestNextSteps(request),
      suggestedPeople,
    };

    // í•™ìŠµ ê¸°íšŒ ì‹ë³„
    if (request.urgency !== 'blocking') {
      response.learningOpportunity = await this.identifyLearningOpportunity(request);
    }

    return response;
  }

  /**
   * ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
   */
  async updateProgress(
    planId: string,
    stepId: string,
    status: OnboardingStep['status']
  ): Promise<OnboardingPlan> {
    return this.progressTracker.updateStep(planId, stepId, status);
  }

  /**
   * ë‹¤ìŒ ë‹¨ê³„ ì¶”ì²œ
   */
  async recommendNextStep(planId: string): Promise<{
    step: OnboardingStep;
    reasoning: string;
  }> {
    const plan = await this.getPlan(planId);

    // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ë‹¨ê³„ ì°¾ê¸°
    const currentPhase = plan.phases.find((p) => p.id === plan.progress.currentPhase);
    if (!currentPhase) throw new Error('Current phase not found');

    // ì™„ë£Œë˜ì§€ ì•Šì€ ë‹¤ìŒ ë‹¨ê³„ ì°¾ê¸°
    const nextStep = currentPhase.steps.find((s) => s.status === 'not-started');
    if (!nextStep) {
      // ë‹¤ìŒ í˜ì´ì¦ˆë¡œ ì´ë™
      const nextPhase = plan.phases.find((p) => p.order === currentPhase.order + 1);
      if (nextPhase) {
        return {
          step: nextPhase.steps[0],
          reasoning: `ë‹¤ìŒ ë‹¨ê³„(${nextPhase.name})ë¡œ ì´ë™í•©ë‹ˆë‹¤.`,
        };
      }
      throw new Error('All steps completed');
    }

    return {
      step: nextStep,
      reasoning: 'í˜„ì¬ ë‹¨ê³„ì˜ ë‹¤ìŒ í•™ìŠµ í•­ëª©ì…ë‹ˆë‹¤.',
    };
  }

  /**
   * í•™ìŠµ ê²½ë¡œ ì¡°ì •
   */
  async adjustPath(
    planId: string,
    adjustment: {
      skipSteps?: string[];
      addSteps?: Partial<OnboardingStep>[];
      extendPhase?: { phaseId: string; extraDays: number };
    }
  ): Promise<OnboardingPlan> {
    const plan = await this.getPlan(planId);

    // skipSteps ì²˜ë¦¬
    if (adjustment.skipSteps) {
      for (const phase of plan.phases) {
        for (const step of phase.steps) {
          if (adjustment.skipSteps.includes(step.id)) {
            step.status = 'completed';
          }
        }
      }
    }

    // addSteps ì²˜ë¦¬
    if (adjustment.addSteps) {
      // íŠ¹ì • í˜ì´ì¦ˆì— ì¶”ê°€
      plan.phases[0]?.steps.push(...(adjustment.addSteps as OnboardingStep[]));
    }

    // extendPhase ì²˜ë¦¬
    if (adjustment.extendPhase) {
      const phase = plan.phases.find((p) => p.id === adjustment.extendPhase!.phaseId);
      if (phase) {
        phase.durationDays += adjustment.extendPhase.extraDays;
      }
    }

    await this.persistPlan(plan);

    return plan;
  }

  // Helper methods
  private calculateEndDate(startDate: Date, phases: OnboardingPhase[]): Date {
    const totalDays = phases.reduce((sum, p) => sum + p.durationDays, 0);
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + totalDays);
    return endDate;
  }

  private async persistPlan(plan: OnboardingPlan): Promise<void> {
    // DB ì €ì¥ ë¡œì§
  }

  private async getPlan(planId: string): Promise<OnboardingPlan> {
    // DB ì¡°íšŒ ë¡œì§
    return {} as OnboardingPlan;
  }

  private async findSimilarQuestions(
    request: ContextualHelpRequest
  ): Promise<Array<{ question: string; answer: string }>> {
    // ìœ ì‚¬ ì§ˆë¬¸ ê²€ìƒ‰ ë¡œì§
    return [];
  }

  private async suggestPeople(
    request: ContextualHelpRequest
  ): Promise<ContextualHelpResponse['suggestedPeople']> {
    // íŒ€ì› ì¶”ì²œ ë¡œì§
    return [];
  }

  private generateAnswer(
    request: ContextualHelpRequest,
    wikiContext: string,
    similarQuestions: Array<{ question: string; answer: string }>
  ): string {
    // AIë¥¼ ì‚¬ìš©í•œ ë‹µë³€ ìƒì„±
    return `Based on wiki content and similar questions...`;
  }

  private extractResources(wikiContext: string): ResourceReference[] {
    // ë¦¬ì†ŒìŠ¤ ì¶”ì¶œ ë¡œì§
    return [];
  }

  private suggestNextSteps(request: ContextualHelpRequest): string[] {
    return [
      'ê´€ë ¨ wiki ë¬¸ì„œë¥¼ ì½ì–´ë³´ì„¸ìš”',
      'ë©˜í† ì™€ 15ë¶„ í‹°íƒ€ì„ì„ ì¡ìœ¼ì„¸ìš”',
      'ë¹„ìŠ·í•œ ì½”ë“œë¥¼ ê²€ìƒ‰í•´ë³´ì„¸ìš”',
    ];
  }

  private async identifyLearningOpportunity(
    request: ContextualHelpRequest
  ): Promise<ContextualHelpResponse['learningOpportunity']> {
    // í•™ìŠµ ê¸°íšŒ ì‹ë³„ ë¡œì§
    return undefined;
  }
}
```

### 2.4 Path Generator

```typescript
// packages/workflow-engine/src/communication/onboarding/path-generator.ts

import type {
  OnboardingPhase,
  OnboardingStep,
  ExtendedTeamRole,
  ResourceReference,
} from '@rtb-ai-hub/shared';
import { WikiKnowledge } from '../../utils/wiki-knowledge';

export class PathGenerator {
  constructor(private wikiPath: string) {}

  /**
   * ì—­í• ë³„ í•™ìŠµ ê²½ë¡œ ìƒì„±
   */
  async generate(
    role: ExtendedTeamRole,
    pace: 'standard' | 'accelerated' | 'extended',
    priorExperience?: string[]
  ): Promise<OnboardingPhase[]> {
    const basePhases = this.getBasePhases(role);

    // í˜ì´ìŠ¤ì— ë”°ë¥¸ ì¡°ì •
    const adjustedPhases = this.adjustForPace(basePhases, pace);

    // ì‚¬ì „ ê²½í—˜ì— ë”°ë¥¸ ìŠ¤í‚µ
    if (priorExperience) {
      return this.skipKnownTopics(adjustedPhases, priorExperience);
    }

    return adjustedPhases;
  }

  /**
   * ê¸°ë³¸ í˜ì´ì¦ˆ ì •ì˜
   */
  private getBasePhases(role: ExtendedTeamRole): OnboardingPhase[] {
    const phases: Record<ExtendedTeamRole, OnboardingPhase[]> = {
      pm: [
        {
          id: 'phase-1',
          name: 'ë„ë©”ì¸ ì´í•´',
          order: 1,
          durationDays: 3,
          steps: [
            this.createReadingStep('RTB ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸', ['rtb-common/RTB_CONTEXT.md']),
            this.createReadingStep('ì£¼ìš” ìš©ì–´ì§‘', ['rtb-common/glossary.md']),
            this.createMeetingStep('PM íŒ€ ì†Œê°œ'),
          ],
          completionCriteria: [],
          status: 'pending',
        },
        {
          id: 'phase-2',
          name: 'ì œí’ˆ ì´í•´',
          order: 2,
          durationDays: 5,
          steps: [
            this.createReadingStep('ì œí’ˆ ë¡œë“œë§µ', ['product/roadmap.md']),
            this.createTaskStep('ì‚¬ìš©ì í”Œë¡œìš° ë”°ë¼ê°€ê¸°'),
            this.createShadowingStep('ìŠ¤í”„ë¦°íŠ¸ í”Œë˜ë‹ ì°¸ê´€'),
          ],
          completionCriteria: [],
          status: 'pending',
        },
      ],
      'backend-developer': [
        {
          id: 'phase-1',
          name: 'í™˜ê²½ ì„¤ì •',
          order: 1,
          durationDays: 1,
          steps: [
            this.createInteractiveStep('ê°œë°œ í™˜ê²½ ì„¤ì •', ['developer/setup-guide.md']),
            this.createTaskStep('ì²« ì»¤ë°‹'),
          ],
          completionCriteria: [],
          status: 'pending',
        },
        {
          id: 'phase-2',
          name: 'ì•„í‚¤í…ì²˜ ì´í•´',
          order: 2,
          durationDays: 3,
          steps: [
            this.createReadingStep('ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜', ['architecture/overview.md']),
            this.createReadingStep('DB ìŠ¤í‚¤ë§ˆ', ['rtb-common/db-schema/manage/_overview.md']),
            this.createCodeReviewStep('ì½”ë“œë² ì´ìŠ¤ ë‘˜ëŸ¬ë³´ê¸°'),
          ],
          completionCriteria: [],
          status: 'pending',
        },
        {
          id: 'phase-3',
          name: 'ì²« ê¸°ì—¬',
          order: 3,
          durationDays: 5,
          steps: [
            this.createTaskStep('good-first-issue í•´ê²°'),
            this.createShadowingStep('ì½”ë“œ ë¦¬ë·° ì°¸ì—¬'),
            this.createTaskStep('ì²« PR ë¨¸ì§€'),
          ],
          completionCriteria: [],
          status: 'pending',
        },
      ],
      // ... ë‹¤ë¥¸ ì—­í• ë“¤
    };

    return phases[role] || phases['backend-developer'];
  }

  /**
   * í˜ì´ìŠ¤ì— ë”°ë¥¸ ì¡°ì •
   */
  private adjustForPace(
    phases: OnboardingPhase[],
    pace: 'standard' | 'accelerated' | 'extended'
  ): OnboardingPhase[] {
    const multiplier = {
      standard: 1,
      accelerated: 0.7,
      extended: 1.5,
    }[pace];

    return phases.map((phase) => ({
      ...phase,
      durationDays: Math.ceil(phase.durationDays * multiplier),
    }));
  }

  /**
   * ì•Œê³  ìˆëŠ” ì£¼ì œ ìŠ¤í‚µ
   */
  private skipKnownTopics(phases: OnboardingPhase[], priorExperience: string[]): OnboardingPhase[] {
    return phases.map((phase) => ({
      ...phase,
      steps: phase.steps.map((step) => {
        const shouldSkip = priorExperience.some((exp) =>
          step.name.toLowerCase().includes(exp.toLowerCase())
        );
        return {
          ...step,
          status: shouldSkip ? 'completed' : step.status,
        };
      }),
    }));
  }

  // Helper methods for creating steps
  private createReadingStep(name: string, wikiPaths: string[]): OnboardingStep {
    return {
      id: generateId('step'),
      name,
      type: 'reading',
      content: {
        title: name,
        description: `${name}ì— ëŒ€í•´ í•™ìŠµí•©ë‹ˆë‹¤`,
        resources: wikiPaths.map((path) => ({
          type: 'wiki',
          title: path.split('/').pop() || '',
          url: path,
        })),
        estimatedDurationMinutes: 60,
      },
      completion: {
        type: 'self-check',
        requirements: ['ë¬¸ì„œë¥¼ ì½ê³  ì´í•´í–ˆëŠ”ì§€ í™•ì¸'],
      },
      status: 'not-started',
    };
  }

  private createTaskStep(name: string): OnboardingStep {
    return {
      id: generateId('step'),
      name,
      type: 'task',
      content: {
        title: name,
        description: `${name}ì„(ë¥¼) ì™„ë£Œí•©ë‹ˆë‹¤`,
        resources: [],
        estimatedDurationMinutes: 120,
      },
      completion: {
        type: 'task-completion',
        requirements: ['ì‘ì—… ì™„ë£Œ'],
      },
      status: 'not-started',
    };
  }

  private createMeetingStep(name: string): OnboardingStep {
    return {
      id: generateId('step'),
      name,
      type: 'meeting',
      content: {
        title: name,
        description: `${name} ë¯¸íŒ…`,
        resources: [],
        estimatedDurationMinutes: 30,
      },
      completion: {
        type: 'self-check',
        requirements: ['ë¯¸íŒ… ì°¸ì„'],
      },
      status: 'not-started',
    };
  }

  private createInteractiveStep(name: string, wikiPaths: string[]): OnboardingStep {
    return {
      id: generateId('step'),
      name,
      type: 'interactive',
      content: {
        title: name,
        description: `${name}ì„(ë¥¼) ì§ì ‘ ì‹¤ìŠµí•©ë‹ˆë‹¤`,
        resources: wikiPaths.map((path) => ({
          type: 'wiki',
          title: path.split('/').pop() || '',
          url: path,
        })),
        estimatedDurationMinutes: 90,
      },
      completion: {
        type: 'task-completion',
        requirements: ['ì‹¤ìŠµ ì™„ë£Œ'],
      },
      status: 'not-started',
    };
  }

  private createCodeReviewStep(name: string): OnboardingStep {
    return {
      id: generateId('step'),
      name,
      type: 'interactive',
      content: {
        title: name,
        description: 'ì½”ë“œë² ì´ìŠ¤ë¥¼ íƒìƒ‰í•˜ê³  ì£¼ìš” íŒ¨í„´ì„ ì´í•´í•©ë‹ˆë‹¤',
        resources: [],
        estimatedDurationMinutes: 120,
      },
      completion: {
        type: 'mentor-approval',
        requirements: ['ì½”ë“œ íˆ¬ì–´ ì™„ë£Œ'],
      },
      status: 'not-started',
    };
  }

  private createShadowingStep(name: string): OnboardingStep {
    return {
      id: generateId('step'),
      name,
      type: 'shadowing',
      content: {
        title: name,
        description: 'ê²½í—˜ ìˆëŠ” íŒ€ì›ì˜ ì—…ë¬´ë¥¼ ê´€ì°°í•©ë‹ˆë‹¤',
        resources: [],
        estimatedDurationMinutes: 120,
      },
      completion: {
        type: 'self-check',
        requirements: ['ì‰ë„ì‰ ì™„ë£Œ'],
      },
      status: 'not-started',
    };
  }
}
```

---

## 3. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- Wiki Facilitation í…Œì´ë¸”
CREATE TABLE wiki_suggestions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  trigger_id VARCHAR(100) NOT NULL,
  document_path VARCHAR(500) NOT NULL,
  document_title VARCHAR(500),
  summary TEXT,
  relevance_score DECIMAL(3,2),

  -- reasoning
  matched_keywords TEXT[],
  matched_concepts TEXT[],
  context_gaps TEXT[],

  -- presentation
  urgency VARCHAR(50),
  format VARCHAR(50),

  -- metadata
  suggested_at TIMESTAMPTZ DEFAULT NOW(),
  delivered_at TIMESTAMPTZ,
  acknowledged_at TIMESTAMPTZ,
  feedback VARCHAR(50),

  -- ê´€ê³„
  user_id VARCHAR(200),
  jira_key VARCHAR(50)
);

CREATE INDEX idx_wiki_suggestions_user ON wiki_suggestions(user_id);
CREATE INDEX idx_wiki_suggestions_relevance ON wiki_suggestions(relevance_score);

-- Knowledge Gaps í…Œì´ë¸”
CREATE TABLE knowledge_gaps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  detected_in VARCHAR(200) NOT NULL,
  gap_type VARCHAR(100) NOT NULL,
  description TEXT NOT NULL,
  affected_roles TEXT[],
  severity VARCHAR(50),
  related_wiki_docs TEXT[],
  suggested_resolution TEXT,
  status VARCHAR(50) DEFAULT 'detected',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  resolved_at TIMESTAMPTZ
);

-- Onboarding Plans í…Œì´ë¸”
CREATE TABLE onboarding_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(200) NOT NULL UNIQUE,
  role VARCHAR(50) NOT NULL,
  start_date TIMESTAMPTZ NOT NULL,
  expected_end_date TIMESTAMPTZ,
  phases JSONB DEFAULT '[]',
  progress JSONB DEFAULT '{}',
  mentor_id VARCHAR(200),
  config JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Onboarding Progress í…Œì´ë¸”
CREATE TABLE onboarding_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_id UUID NOT NULL REFERENCES onboarding_plans(id) ON DELETE CASCADE,
  step_id VARCHAR(100) NOT NULL,
  status VARCHAR(50) NOT NULL,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  notes TEXT,
  UNIQUE(plan_id, step_id)
);

-- Mentor Profiles í…Œì´ë¸”
CREATE TABLE mentor_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(200) NOT NULL UNIQUE,
  role VARCHAR(50) NOT NULL,
  expertise JSONB DEFAULT '{}',
  mentoring_stats JSONB DEFAULT '{}',
  availability JSONB DEFAULT '{}',
  is_available BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Contextual Help History í…Œì´ë¸”
CREATE TABLE contextual_help_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(200) NOT NULL,
  question TEXT NOT NULL,
  context JSONB DEFAULT '{}',
  answer TEXT,
  resources JSONB DEFAULT '[]',
  helpful BOOLEAN,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_contextual_help_user ON contextual_help_history(user_id);
```

---

## 4. í†µí•© ì˜ˆì‹œ

```typescript
// ì‚¬ìš© ì˜ˆì‹œ

// 1. ì˜¨ë³´ë”© ì‹œì‘
const onboarding = new OnboardingService('/path/to/wiki');
const plan = await onboarding.createOnboardingPlan(
  'new-developer@company.com',
  'backend-developer',
  {
    startDate: new Date(),
    pace: 'standard',
    priorExperience: ['nodejs', 'postgresql'],
  }
);

// 2. ì‹¤ì‹œê°„ ë„ì›€ ìš”ì²­
const help = await onboarding.provideContextualHelp({
  id: 'help-1',
  userId: 'new-developer@company.com',
  role: 'backend-developer',
  context: {
    currentTask: 'ë¡œê·¸ì¸ API êµ¬í˜„',
    currentFile: 'src/auth/controller.ts',
  },
  question: 'JWT í† í°ì€ ì–´ë””ì— ì €ì¥í•´ì•¼ í•˜ë‚˜ìš”?',
  urgency: 'blocking',
});

// 3. Wiki ì œì•ˆ
const facilitator = new WikiFacilitationService('/path/to/wiki');
const { suggestions } = await facilitator.analyzeAndSuggest({
  id: 'trigger-1',
  source: 'slack',
  sourceId: 'msg-123',
  content: {
    text: 'obj_bld_mst í…Œì´ë¸”ì— ìƒˆ ì»¬ëŸ¼ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤',
    author: { userId: 'dev@company.com', role: 'backend-developer' },
    timestamp: new Date(),
  },
  context: {
    jiraKey: 'PROJ-123',
    participants: ['backend-developer', 'pm'],
  },
});
```

---

ë‹¤ìŒ ë‹¨ê³„:

1. **ë°ì´í„° ëª¨ë¸ ë° API ì„¤ê³„** - í†µí•© REST/GraphQL API ì •ì˜
2. **í†µí•© ë° í™•ì¥ ì „ëµ** - ê¸°ì¡´ ì‹œìŠ¤í…œê³¼ì˜ í†µí•© ë°©ì•ˆ

ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?
